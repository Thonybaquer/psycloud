'use server';

import { db } from '@/db';
import { expenses } from '@/db/schema';
import { requireSession, canSeeLegacy } from '@/lib/serverAuth';
import { and, eq, or, sql } from 'drizzle-orm';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';
import { parseMoneyToCents } from '@/lib/money';
import { userSettings } from '@/db/schema';

const ExpenseInput = z.object({
  date: z.string().min(4),
  title: z.string().min(1),
  category: z.string().optional(),
  method: z.string().optional(),
  amountCOP: z.union([z.string(), z.number()]),
  notes: z.string().optional(),
  recurring: z.union([z.boolean(), z.string()]).optional(),
});

async function getMoneyDecimals(uid: string): Promise<number> {
  try {
    const row = await db.select().from(userSettings).where(eq(userSettings.userId, uid)).get();
    const settings = row?.settingsJson ? JSON.parse(row.settingsJson) : {};
    const d = Number(settings?.money?.decimals ?? 0);
    return Number.isFinite(d) ? Math.max(0, Math.min(2, Math.round(d))) : 0;
  } catch {
    return 0;
  }
}

function centsFromMoney(v: unknown, decimals: number): number {
  return parseMoneyToCents(typeof v === 'number' ? String(v) : String(v ?? ''), decimals);
}

function expenseScope(session: any) {
  if (canSeeLegacy(session)) {
    return or(eq(expenses.userId, session.userId), sql`${expenses.userId} IS NULL`);
  }
  return eq(expenses.userId, session.userId);
}

export async function createExpense(input: unknown) {
  const session = await requireSession();
  const data = ExpenseInput.parse(input);

  const now = new Date().toISOString();
  const id = crypto.randomUUID();
  const isRecurring = Boolean(data.recurring === true || data.recurring === 'true' || data.recurring === 'on');

  const dateOnly = String(data.date).slice(0, 10);
  const day = (() => {
    const d = new Date(`${dateOnly}T00:00:00`);
    return Number.isFinite(d.getTime()) ? d.getDate() : 1;
  })();
  const recurringGroup = isRecurring ? crypto.randomUUID() : null;

  const decimals = await getMoneyDecimals(session.userId);

  await db.insert(expenses).values({
    id,
    userId: session.userId,
    date: data.date,
    title: data.title.trim(),
    category: (data.category ?? '').trim() || null,
    method: (data.method ?? '').trim() || null,
    amountCents: centsFromMoney(data.amountCOP, decimals),
    notes: (data.notes ?? '').trim() || null,
    recurring: isRecurring,
    recurringGroup: recurringGroup,
    recurringDay: isRecurring ? day : null,
    recurringStart: isRecurring ? dateOnly : null,
    autoGenerated: false,
    createdAt: now,
    updatedAt: now,
  });

  revalidatePath('/finance');
  return { ok: true, id };
}

const UpdateInput = z.object({
  id: z.string().min(1),
  date: z.string().optional(),
  title: z.string().optional(),
  category: z.string().optional().nullable(),
  method: z.string().optional().nullable(),
  amountCOP: z.union([z.string(), z.number()]).optional(),
  notes: z.string().optional().nullable(),
  recurring: z.union([z.boolean(), z.string()]).optional(),
});

export async function updateExpense(input: unknown) {
  const session = await requireSession();
  const data = UpdateInput.parse(input);

  const patch: any = { updatedAt: new Date().toISOString() };

  if (data.date !== undefined) patch.date = data.date;
  if (data.title !== undefined) patch.title = data.title.trim();
  if (data.category !== undefined) patch.category = (data.category ?? '').trim() || null;
  if (data.method !== undefined) patch.method = (data.method ?? '').trim() || null;
  if (data.amountCOP !== undefined) {
    const decimals = await getMoneyDecimals(session.userId);
    patch.amountCents = centsFromMoney(data.amountCOP, decimals);
  }
  if (data.notes !== undefined) patch.notes = (data.notes ?? '').trim() || null;
  if (data.recurring !== undefined) patch.recurring = Boolean(data.recurring === true || data.recurring === 'true' || data.recurring === 'on');

  // If turning recurring ON, ensure recurring metadata is set
  if (data.recurring !== undefined && patch.recurring === true) {
    const existing = await db.select().from(expenses).where(and(eq(expenses.id, data.id), expenseScope(session))).get() as any;
    if (existing && !existing.recurringGroup) {
      const dateOnly = String((data.date ?? existing.date) ?? '').slice(0, 10);
      const d = new Date(`${dateOnly}T00:00:00`);
      const day = Number.isFinite(d.getTime()) ? d.getDate() : 1;
      patch.recurringGroup = crypto.randomUUID();
      patch.recurringDay = day;
      patch.recurringStart = String(existing.date ?? dateOnly).slice(0, 10);
      patch.autoGenerated = false;
    }
  }

  await db.update(expenses).set(patch).where(and(eq(expenses.id, data.id), expenseScope(session)));

  revalidatePath('/finance');
  return { ok: true };
}

export async function deleteExpense(id: string) {
  const session = await requireSession();
  await db.delete(expenses).where(and(eq(expenses.id, id), expenseScope(session)));
  revalidatePath('/finance');
  return { ok: true };
}