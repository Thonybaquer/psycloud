import Link from 'next/link';
import { db } from '@/db';
import { appointments, expenses, patients } from '@/db/schema';
import { and, eq, gte, lte, or, sql } from 'drizzle-orm';
import { requireSession, canSeeLegacy } from '@/lib/serverAuth';
import { FinanceClient } from './FinanceClient';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

function startOfMonth(d: Date) {
  return new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);
}
function endOfMonth(d: Date) {
  return new Date(d.getFullYear(), d.getMonth() + 1, 0, 23, 59, 59, 999);
}

function fmtCOP(cents: number) {
  const v = Math.round((cents ?? 0) / 100);
  return new Intl.NumberFormat('es-CO', { style: 'currency', currency: 'COP', maximumFractionDigits: 0 }).format(v);
}

function scopeFor(session: any, col: any) {
  // Use typed expressions (eq/or) to avoid raw SQL edge-cases.
  if (canSeeLegacy(session)) {
    return or(eq(col, session.userId), sql`${col} IS NULL`);
  }
  return eq(col, session.userId);
}


function monthKey(d: Date) {
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
}

async function ensureRecurringExpensesForMonth(session: any, monthStart: Date) {
  // Recurring expenses are treated as "templates" when autoGenerated = 0.
  const targetKey = monthKey(monthStart);

  // Fetch recurring templates for this user (or legacy NULL user_id)
  const templates = await db
    .select()
    .from(expenses)
    .where(and(eq(expenses.recurring, true), scopeFor(session, expenses.userId)))
    .all();

  // Normalize older rows: set recurringGroup/day/start if missing.
  for (const t of templates as any[]) {
    if (!t.recurring) continue;
    const needsGroup = !t.recurringGroup;
    const needsDay = !t.recurringDay;
    const needsStart = !t.recurringStart;
    if (needsGroup || needsDay || needsStart || t.autoGenerated === null || t.autoGenerated === undefined) {
      const d = new Date(`${String(t.date).slice(0, 10)}T00:00:00`);
      const day = Number.isFinite(d.getTime()) ? d.getDate() : 1;
      await db
        .update(expenses)
        .set({
          recurringGroup: t.recurringGroup ?? t.id,
          recurringDay: t.recurringDay ?? day,
          recurringStart: t.recurringStart ?? String(t.date).slice(0, 10),
          autoGenerated: Boolean(t.autoGenerated ?? false),
          updatedAt: new Date().toISOString(),
        } as any)
        .where(and(eq(expenses.id, t.id), scopeFor(session, expenses.userId)));
    }
  }

  // Re-fetch normalized templates (only non-auto generated)
  const normalized = (await db
    .select()
    .from(expenses)
    .where(and(eq(expenses.recurring, true), eq(expenses.autoGenerated, false), scopeFor(session, expenses.userId)))
    .all()) as any[];

  const byGroup = new Map<string, any>();
  for (const t of normalized) {
    const g = t.recurringGroup ?? t.id;
    if (!byGroup.has(g)) byGroup.set(g, t);
    else {
      // pick earliest as template
      const a = String(byGroup.get(g).recurringStart ?? byGroup.get(g).date);
      const b = String(t.recurringStart ?? t.date);
      if (b < a) byGroup.set(g, t);
    }
  }

  for (const [group, tpl] of byGroup.entries()) {
    // Skip if recurrence hasn't started yet
    const start = String(tpl.recurringStart ?? tpl.date).slice(0, 7);
    if (start > targetKey) continue;

    const monthEnd = endOfMonth(monthStart);
    const fromDate = monthStart.toISOString().slice(0, 10);
    const toDate = monthEnd.toISOString().slice(0, 10);
    const exists = await db
      .select({ id: expenses.id })
      .from(expenses)
      .where(
        and(
          eq(expenses.recurringGroup, group as any),
          gte(expenses.date, fromDate),
          lte(expenses.date, toDate),
          scopeFor(session, expenses.userId),
        ),
      )
      .get();
    if (exists?.id) continue;

    const day = Number(tpl.recurringDay ?? 1);
    const y = monthStart.getFullYear();
    const m = monthStart.getMonth();
    const last = new Date(y, m + 1, 0).getDate();
    const useDay = Math.max(1, Math.min(day || 1, last));
    const date = `${y}-${String(m + 1).padStart(2, '0')}-${String(useDay).padStart(2, '0')}`;

    const now = new Date().toISOString();
    await db.insert(expenses).values({
      id: crypto.randomUUID(),
      userId: session.userId,
      date,
      title: tpl.title,
      category: tpl.category,
      method: tpl.method,
      amountCents: tpl.amountCents ?? 0,
      notes: tpl.notes,
      recurring: true,
      recurringGroup: group,
      recurringDay: day || 1,
      recurringStart: String(tpl.recurringStart ?? tpl.date).slice(0, 10),
      autoGenerated: true,
      createdAt: now,
      updatedAt: now,
    } as any);
  }
}

export default async function FinancePage({ searchParams }: { searchParams?: Promise<{ month?: string }> }) {
  const session = await requireSession();

  const now = new Date();
  const sp = (searchParams ? await searchParams : undefined) as any;
  const m = (sp?.month ?? '').trim();
  const base = m && /^\d{4}-\d{2}$/.test(m) ? new Date(`${m}-01T00:00:00`) : now;
  const from = startOfMonth(base);
  const to = endOfMonth(base);

  // Auto-create missing recurring expenses for this month ("fijos")
  await ensureRecurringExpensesForMonth(session, from);


  const incomeRows = await db
    .select({
      id: appointments.id,
      patientId: appointments.patientId,
      startIso: appointments.date,
      status: appointments.status,
      feeCents: appointments.feeCents,
      paymentStatus: appointments.paymentStatus,
      paymentMethod: appointments.paymentMethod,
      patientName: patients.fullName,
    })
    .from(appointments)
    .leftJoin(patients, eq(patients.id, appointments.patientId))
    .where(and(gte(appointments.date, from.toISOString()), lte(appointments.date, to.toISOString()), scopeFor(session, appointments.userId)))
    .all();

  const expenseRows = await db
    .select({
      id: expenses.id,
      date: expenses.date,
      title: expenses.title,
      category: expenses.category,
      method: expenses.method,
      amountCents: expenses.amountCents,
      notes: expenses.notes,
      recurring: expenses.recurring,
      createdAt: expenses.createdAt,
      updatedAt: expenses.updatedAt,
    })
    .from(expenses)
    .where(
      and(
        gte(expenses.date, from.toISOString().slice(0, 10)),
        lte(expenses.date, to.toISOString().slice(0, 10)),
        scopeFor(session, expenses.userId),
      ),
    )
    .all();

  

// Data for year-level charts (month/year breakdown, categories, top gastos)
const year = from.getFullYear();
const yearFrom = new Date(year, 0, 1, 0, 0, 0, 0);
const yearTo = new Date(year, 11, 31, 23, 59, 59, 999);

const yearIncomeRows = await db
  .select({ startIso: appointments.date, feeCents: appointments.feeCents, paymentStatus: appointments.paymentStatus })
  .from(appointments)
  .where(and(gte(appointments.date, yearFrom.toISOString()), lte(appointments.date, yearTo.toISOString()), scopeFor(session, appointments.userId)))
  .all();


const yearPatientRows = await db
  .select({ startIso: appointments.date, patientId: appointments.patientId, status: appointments.status })
  .from(appointments)
  .where(and(gte(appointments.date, yearFrom.toISOString()), lte(appointments.date, yearTo.toISOString()), scopeFor(session, appointments.userId)))
  .all();


const yearExpenseRows = await db
  .select({ date: expenses.date, amountCents: expenses.amountCents, category: expenses.category, title: expenses.title })
  .from(expenses)
  .where(
    and(
      gte(expenses.date, yearFrom.toISOString().slice(0, 10)),
      lte(expenses.date, yearTo.toISOString().slice(0, 10)),
      scopeFor(session, expenses.userId),
    ),
  )
  .all();
const totalBilled = incomeRows.reduce((a, r) => a + (r.feeCents ?? 0), 0);
  const totalPaid = incomeRows.filter((r) => r.paymentStatus === 'paid').reduce((a, r) => a + (r.feeCents ?? 0), 0);
  const totalPending = totalBilled - totalPaid;

  const totalExpenses = expenseRows.reduce((a, r) => a + (r.amountCents ?? 0), 0);
  const net = totalPaid - totalExpenses;

  const debtMap = new Map<string, { patientId: string; patientName: string; amount: number }>();
  for (const r of incomeRows) {
    if (r.paymentStatus === 'paid') continue;
    const pid = r.patientId;
    if (!pid) continue;
    const cur = debtMap.get(pid) ?? { patientId: pid, patientName: r.patientName ?? 'Paciente', amount: 0 };
    cur.amount += r.feeCents ?? 0;
    debtMap.set(pid, cur);
  }
  const debtors = [...debtMap.values()].sort((a, b) => b.amount - a.amount);

  const label = `${from.getFullYear()}-${String(from.getMonth() + 1).padStart(2, '0')}`;

  return (
    <div className="min-h-screen p-6 md:p-8">
      <div className="max-w-7xl mx-auto">
        <div className="mb-6 flex items-start justify-between gap-4">
          <div>
            <Link href="/" className="text-sm text-slate-600 dark:text-slate-300 hover:underline">
              ‚Üê Volver al Dashboard
            </Link>
            <h1 className="text-2xl font-bold mt-2">Finanzas</h1>
            <p className="text-sm text-slate-500 dark:text-slate-300">Ingresos, egresos y utilidad real</p>
          </div>

          <form className="flex items-center gap-2">
            <label className="text-xs text-slate-500 dark:text-slate-300">Mes</label>
            <input
              type="month"
              name="month"
              defaultValue={label}
              className="border border-slate-200 dark:border-slate-700 rounded-xl px-3 py-2 bg-white dark:bg-slate-950 text-slate-800 dark:text-slate-100"
            />
            <button type="submit" className="px-4 py-2 rounded-xl bg-blue-600 text-white font-semibold hover:bg-blue-700">
              Ver
            </button>
          </form>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <SummaryCard label="Ingresos cobrados" value={fmtCOP(totalPaid)} />
          <SummaryCard label="Egresos" value={fmtCOP(totalExpenses)} />
          <SummaryCard label="Utilidad real" value={fmtCOP(net)} emphasis={net >= 0 ? 'good' : 'bad'} />
          <SummaryCard label="Pendiente por cobrar" value={fmtCOP(totalPending)} />
        </div>

        <FinanceClient
          monthLabel={label}
          incomeRows={incomeRows as any}
          expenseRows={expenseRows as any}
          debtors={debtors}
          yearIncomeRows={yearIncomeRows as any}
          yearExpenseRows={yearExpenseRows as any}
          yearPatientRows={yearPatientRows as any}
          totals={{
            billedCents: totalBilled,
            paidCents: totalPaid,
            pendingCents: totalPending,
            expenseCents: totalExpenses,
            netCents: net,
          }}
        />
      </div>
    </div>
  );
}

function SummaryCard({ label, value, emphasis }: { label: string; value: string; emphasis?: 'good' | 'bad' }) {
  return (
    <div className="pc-card bg-white dark:bg-slate-950">
      <div className="text-xs font-semibold text-slate-500 dark:text-slate-300">{label}</div>
      <div
        className={`text-2xl font-extrabold mt-1 ${
          emphasis === 'good'
            ? 'text-emerald-700 dark:text-emerald-300'
            : emphasis === 'bad'
              ? 'text-rose-700 dark:text-rose-300'
              : 'text-slate-800 dark:text-slate-100'
        }`}
      >
        {value}
      </div>
    </div>
  );
}
